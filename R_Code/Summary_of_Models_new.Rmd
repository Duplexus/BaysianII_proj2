## Source All Files if still needed:
```{r }
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

library("nimble")
library("coda")
```

```{r }
source("..\\R_Code\\helpfunctions.r")
source("..\\R_Code\\lmm.r")
source("..\\R_Code\\Beta_Modell.r")
source("..\\R_Code\\Beta_Modell_age_spline.r")
source("..\\R_Code\\Beta_Modell_day_spline.r")
source("..\\R_Code\\Beta_Modell_age_day_spline.r")
source("..\\R_Code\\Beta_Modell_day_pen_spline.r")
```

## LMM sofa
```{r }
source("..\\R_Code\\helpfunctions.r")
#source("..\\R_Code\\lmm.r")
library(nimble)
#result is sofa_lmm
sofa_lmm <- readRDS("..\\data\\mcmc_res\\sofa_lmm.Rds")

```
```{r }
sofa_lmms <- subset_coda_params(data = sofa_lmm$samples, variable = c("sigma2", "beta0", "beta1", "beta2","sigma2_b0","tau"))
sofa_lmm$WAIC$WAIC
summarise_default(sofa_lmms)
```

### Explore predictions
```{r }
y_pred_lmm <- get_params(c("y_pred"),sofa_lmm$samples)
plot(data$sofa, y_pred_lmm)
exists <- !is.na(data$sofa)
cor(data$sofa[exists], y_pred_lmm[exists])

data$sofa_pred <- y_pred_lmm
```


## Beta beta_rand
### some Summary
```{r }
source("helpfunctions.r")
#source("Beta_Modell.r")
#result ist beta_rand
beta_rand <- readRDS("..\\data\\mcmc_res\\beta_rand.rds")
```

```{r }
ai_beta <- subset_coda_params(data = beta_rand$samples, variable = c("beta0", "beta1", "beta2","sigma_b0","phi"))
beta_rand$WAIC$WAIC
summarise_default(ai_beta)
```

### Explore predictions
```{r }
library(lme4)
y_pred_beta <- get_params(c("y_pred"),beta_rand$samples)
plot(data$ai, y_pred_beta)
cor(data$ai, y_pred_beta)

data$ai_pred <- y_pred_beta
saveRDS(data, file = "..\\data\\Prep_data_for_ex3.rds")

data <- readRDS("..\\data\\AIdataset_normalized.Rds")
```
### some Plots

```{r}
source("helpfunctions.r")
#beta 1 age beta2 day
beta_means <- get_params(c("beta0", "beta1","beta2","sigma_b0","phi"),beta_rand$samples)
#age and day are transformed therefore also here some transofrmation
age <- -0
day <- c(-6,22)

mu <- expit(beta_means["beta0"]+beta_means["beta1"]*age + beta_means["beta2"]*day)
phi <- beta_means["phi"]
a <- mu * phi
b <- (1 - mu) * phi

gr1_low <- qbeta(0.025, a , b)
gr1_mid <- qbeta(0.5, a , b)
gr1_up <- qbeta(0.975, a , b)

plot(data$day, data$ai,  pch = 19, lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability")
lines(day,gr1_low, col = 2,lty = 2, lwd = 3)
lines(day,gr1_mid, col = 2, lwd = 3)
lines(day,gr1_up, col = 2,lty = 2, lwd = 3)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")


```

## Beta Age Spline ai_spline_age
```{r}
source("helpfunctions.r")
#source("Beta_Modell_age_spline.r")
ai_spline_age <- readRDS("..\\data\\mcmc_res\\ai_spline_age.Rds")
##result is ai_spline_age
```
### Summary
```{r}
summarise_default(ai_spline_age$samples)
```

```{r}
ai_spline_age$WAIC$WAIC
```

### Plotting
```{r}

#beta 1 age beta2 day
beta_means <- get_params(c("beta0", "beta_age", "beta2","sigma_b0","phi"),ai_spline_age$samples)
#age and day are transformed therefore also here some transofrmation
age <- 22
day <- c(-6:22)
#works tryed it with the true data, if we would make a bigger project do a unit_test
age <- bSpline(age,Boundary.knots =c(min(data$age),max(data$age)) , knots = c(-20,0,20),degree = 3)
mu <- expit(beta_means["beta0"]+c(beta_means[grepl("beta_age", names(beta_means))]%*%t(age)) + beta_means["beta2"]*day)

phi <- beta_means["phi"]
a <- mu * phi
b <- (1 - mu) * phi

gr1_low <- qbeta(0.025, a , b)
gr1_mid <- qbeta(0.5, a , b)
gr1_up <- qbeta(0.975, a , b)

plot(data$day, data$ai,  pch = 19, lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability", col = data$id)
lines(day,gr1_low, col = 2,lty = 2, lwd = 3)
lines(day,gr1_mid, col = 2, lwd = 3)
lines(day,gr1_up, col = 2,lty = 2, lwd = 3)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")


```
## Beta Day Spline
```{r}
source("helpfunctions.r")
#source("Beta_Modell_day_spline.r")

ai_spline_day <- readRDS("..\\data\\mcmc_res\\ai_spline_day.Rds")

#result is ai_spline_age_day
```

### Summary 
```{r }
summarise_default(ai_spline_age_day$samples)
```
### Plot
```{r}
source("helpfunctions.r")
#beta 1 age beta2 day
#beta_means <- get_params(c("beta0", "beta_age", "beta_day","sigma_b0","phi"),ai_spline_day$samples)

#just the same as subsetting basically
beta_means <- get_params(c("beta0", "beta_age", "beta_day","sigma_b0","phi"),ai_spline_day$samples,functions_ = function(x)x)
#calculate prediction for every set of variables, for chosen x values
#really hand crafted
colnames(beta_means)

age_orig <- 55
day_orig <- c(-10:18)
#var coming from random intercept
get_params(c("sigma_b0"),ai_spline_day$samples)
random <- 0.42
#works tryed it with the true data, if we would make a bigger project do a unit_test
day <- bSpline(-10:18,Boundary.knots =c(min(data$day),max(data$day)) , knots = c(-4,-2,3),degree = 3)

beta_day_spline <- function(x){
  mu <- expit(2*random + x["beta0"]+x["beta_age"]*age_orig + c(x[grepl("beta_day", names(x))]%*%t(day)))
  vergleich <<- (2*random + x["beta0"]+x["beta_age"]*age_orig + c(x[grepl("beta_day", names(x))]%*%t(day)))
  phi <- x["phi"]
  a <- mu * phi
  b <- (1 - mu) * phi
  return(qbeta(0.5, a , b))
}
est_values <- (apply(beta_means,1,beta_day_spline))
#now we have all estimates for all sets off data, now calculate there the quantiles
#the objedct has dim (length(day),length(mcmc_sample))
get_estimates <- apply(est_values,1,quantile,c(0.025,0.5,0.975))

gr1_low <- get_estimates[1,]
gr1_mid <- get_estimates[2,]
gr1_up  <- get_estimates[3,]
plot(data$day, data$ai,  pch = 19, lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability", col = data$id)
lines(day_orig,gr1_low, col = 2,lty = 2, lwd = 3)
lines(day_orig,gr1_mid, col = 2, lwd = 3)
lines(day_orig,gr1_up, col = 2,lty = 2, lwd = 3)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")
# 
# #other method where i just use the quantiles of the total mean of the parameters instead of the quantiles of the estimated values is probably worse
# mu <- expit(beta_means["beta0"]+beta_means["beta_age"]*age_orig + c(beta_means[grepl("beta_day", names(beta_means))]%*%t(day)))
# phi <- beta_means["phi"]
# a <- mu * phi
# b <- (1 - mu) * phi
# 
# gr1_low <- qbeta(0.025, a , b)
# gr1_mid <- qbeta(0.5, a , b)
# gr1_up <- qbeta(0.975, a , b)
# plot(data$day, data$ai,  pch = 19, lwd = 1.5,
#       xlab = "Days", cex.lab = 1.8,
#      ylab = "Overall survival probability", col = data$id)
# lines(day_orig,gr1_low, col = 2,lty = 2, lwd = 3)
# lines(day_orig,gr1_mid, col = 2, lwd = 3)
# lines(day_orig,gr1_up, col = 2,lty = 2, lwd = 3)
# legend("topright", legend = c("SS", "HB"),lwd = 3,
#                lty = 1,col = c(2,3),
#                title = "Groups")
```

## Beta Day Age Spline ai_spline_age_day
```{r}
#source("Beta_Modell_age_day_spline.r")
ai_spline_age_day <- readRDS("..\\data\\mcmc_res\\ai_spline_age_day.Rds")
#result is ai_spline_age_day
```
###Summary
```{r }

summarise_default(ai_spline_age_day$samples)
```
```{r }
ai_spline_age_day$WAIC$WAIC
```


###Plotting
```{r}
source("helpfunctions.r")
#beta 1 age beta2 day
beta_means <- get_params(c("beta0", "beta_age", "beta_day","sigma_b0","phi"),ai_spline_age_day$samples)
#age and day are transformed therefore also here some transofrmation
age_orig <- 22
day_orig <- c(-6:22)
#works tryed it with the true data, if we would make a bigger project do a unit_test
age <- bSpline(age_orig,Boundary.knots =c(min(data$age),max(data$age)) , knots = c(-20,0,20),degree = 3)
day <- bSpline(day_orig,Boundary.knots =c(min(data$day),max(data$day)) , knots = c(-4,-2,3),degree = 3)

mu <- expit(beta_means["beta0"]+c(beta_means[grepl("beta_age", names(beta_means))]%*%t(age)) + c(beta_means[grepl("beta_day", names(beta_means))]%*%t(day)))
phi <- beta_means["phi"]
a <- mu * phi
b <- (1 - mu) * phi


gr1_low <- qbeta(0.025, a , b)
gr1_mid <- qbeta(0.5, a , b)
gr1_up <- qbeta(0.975, a , b)
plot(data$day, data$ai,  pch = 19, lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability", col = data$id)
lines(day_orig,gr1_low, col = 2,lty = 2, lwd = 3)
lines(day_orig,gr1_mid, col = 2, lwd = 3)
lines(day,gr1_up, col = 2,lty = 2, lwd = 3)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")
```


## Beta P-Bsplines Day
```{r}
#source("..\\R_code\\Beta_Modell_day_pen_spline.r")
ai_pspline_day <-readRDS("..\\data\\mcmc_res\\day_pen_spline.Rds")
#result is ai_spline_age_day
```

### Summary 
```{r }
summarise_default(ai_pspline_day$samples)
ai_pspline_day$WAIC$WAIC
```
### with splines a for day a plot
```{r}
source("helpfunctions.r")
#beta 1 age beta2 day
beta_means <- get_params(c("beta0", "beta_age", "beta_day","sigma_b0","phi"),ai_pspline_day$samples)
#age and day are transformed therefore also here some transofrmation
#works tryed it with the true data, if we would make a bigger project do a unit_test
day <- bSpline(day_orig,degree = 3,df = 20)
age_orig <- 22
day_orig <- seq(-15,22,length= ncol(day))

mu <- expit(beta_means["beta0"]+beta_means["beta_age"]*age_orig + c(beta_means[grepl("beta_day", names(beta_means))]%*%t(day)))
phi <- beta_means["phi"]
a <- mu * phi
b <- (1 - mu) * phi


gr1_low <- qbeta(0.025, a , b)
gr1_mid <- qbeta(0.5, a , b)
gr1_up <- qbeta(0.975, a , b)
plot(data$day, data$ai,  pch = 19, lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability", col = data$id)
lines(day_orig,gr1_low, col = 2,lty = 2, lwd = 3)
lines(day_orig,gr1_mid, col = 2, lwd = 3)
lines(day_orig,gr1_up, col = 2,lty = 2, lwd = 3)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")
```



## WAIC comparison
```{r}
cat("no spline WAIC\n")
beta_rand$WAIC$WAIC
cat("\n spline age WAIC\n")
ai_spline_age$WAIC$WAIC
cat("\n spline day WAIC\n")
ai_spline_age_day$WAIC$WAIC
cat("\n spline day, age WAIC\n")
ai_spline_age_day$WAIC$WAIC
cat("\n pspline day WAIC\n")
ai_pspline_day$WAIC$WAIC
```
##### CPO and PPo
I always unluckly wrote PPO instead of CPO so it is the same in this document
 

```{r}
subset_pred <- grepl("ppo\\[", dimnames(lognorm_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_mcmc_rep,subset_pred)
#cpo (leave one out Prediction)
cpo <- (apply(1/as.matrix(mcmc_subset),2,mean))^-1
icpo <- cpo^-1
#ppo (without leave one out, therefore violates liklihoodprinciple(dont predict with same data))
ppo <- (apply(as.matrix(mcmc_subset),2,mean))
ippo <- ppo^-1

plot(icpo)
plot(ippo)
#which y are thebiggest
matrix(order(icpo,decreasing = T),ncol = 14, nrow = 10, byrow = T)
#Table 2 
matrix(order(ippo,decreasing = T),ncol = 14, nrow = 10, byrow = T)


LPLM <- mean(log(cpo))
LPLM
#2.) extract the res values 
subset_pred <- grepl("res\\[", dimnames(lognorm_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_mcmc_rep,subset_pred)
#how look the average residuals in the log world?
hist(apply(mcmc_subset,2,mean), breaks = 20)

```

##### PPC and more summary
PPC how often true y in 95% intervall
```{r}
subset_pred <- grepl("y_rep\\[", dimnames(lognorm_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_mcmc_rep,subset_pred)

# # mcmc_subset
# #how often are the values bigger or smallen than the predicted ones
# max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
# 
# #how do the distribution look like comapred to the origninal one
# summary(mcmc_subset[,1])
# hist(Grub$value)
# hist(mcmc_subset[1,],breaks = 20)

# how extreme are the predicted values compared to the original ones
mean(apply(mcmc_subset,1,function(x){sum(x >= 12)  >= (sum(Grub$value >=12))}))
mean(apply(mcmc_subset,1,function(x){sum(x >= 6)  >= (sum(Grub$value >=6))}))
mean(apply(mcmc_subset,1,function(x){sum(x <= 2)  >= (sum(Grub$value <= 2))}))
```

##### DIC Manual
This is just for comparison to the automatic calculated one. Used later for the interval censored part
```{r}
#3.) Get the DIC running
#https://en.wikipedia.org/wiki/Deviance_information_criterion


subset_pred <- grepl("Deviance", dimnames(lognorm_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_mcmc_rep,subset_pred)
mcmc_subset_dic<- mcmc_subset
md <- mean(mcmc_subset_dic)
#This is the calculation of Pd but somehow it does not work for the random effectmodels for me, probably I have made some mistake, but I cant find it. So I switch to pv instead, https://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-dic/ which is also kinda recomended and is the variance of the posterior divided by 2, comes from some chisquare approx. Explaination on the link can be found. First still the implementation of BIC is written down.
a <- vector()
subset_pred <- grepl("beta0", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta0"] <- mean(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("beta2", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta2"] <- mean(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("beta1", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta1"] <- mean(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("tau", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["tau"] <- mean(get_values(lognorm_mcmc_rep,subset_pred))

pd <- md - (-2 *sum(log(dlnorm(Grub$value,a["beta0"]+a["beta1"]*Grub$grubsize 
                   + a["beta2"]*Grub$group,sqrt(1/a["tau"])))))
pv <- var(mcmc_subset_dic)/2
c(pd,md,pd+md)
c(pv,md,pv+md)

```

##### Plot the Model

```{r}
a <- vector()
subset_pred <- grepl("beta0", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta0"] <- median(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("beta2", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta2"] <- median(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("beta1", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["beta1"] <- median(get_values(lognorm_mcmc_rep,subset_pred))

subset_pred <- grepl("tau", dimnames(lognorm_mcmc_rep[[1]])[[2]])
a["tau"] <- median(get_values(lognorm_mcmc_rep,subset_pred))


# subset_pred <- grepl("y\\[", dimnames(lognorm_mcmc_rep[[1]])[[2]])
# mcmc_subset_y <- get_values(lognorm_mcmc_rep,subset_pred)

size <- seq(-2,4,length.out = 140)
#group 2 beta 2 is the group
gr1_low <- qlnorm(0.025,a["beta0"]+a["beta1"]*size + a["beta2"]*0,sqrt(1/a["tau"]))
gr1_mid <- qlnorm(0.5,a["beta0"]+a["beta1"]*size + a["beta2"]*0,sqrt(1/a["tau"]))
gr1_up <- qlnorm(0.975,a["beta0"]+a["beta1"]*size + a["beta2"]*0,sqrt(1/a["tau"]))
gr2_low <- qlnorm(0.025,a["beta0"]+a["beta1"]*size + a["beta2"]*1,sqrt(1/a["tau"]))
gr2_mid <- qlnorm(0.5,a["beta0"]+a["beta1"]*size + a["beta2"]*1,sqrt(1/a["tau"]))
gr2_up <- qlnorm(0.975,a["beta0"]+a["beta1"]*size + a["beta2"]*1,sqrt(1/a["tau"]))
# 

# y_sample <- apply(mcmc_subset,2,mean)
# Grub$grubsize, Grub$value
# Grub2$grubsize, y_sample
Grub2 <- Grub
plot(Grub$grubsize, Grub$value,  pch = 19,ylim = c(0,20), col = (Grub$group + 2), lwd = 1.5,
      xlab = "Days", cex.lab = 1.8,
     ylab = "Overall survival probability")
lines(size,gr1_low, col = 2,lty = 2, lwd = 3)
lines(size,gr1_mid, col = 2, lwd = 3)
lines(size,gr1_up, col = 2,lty = 2, lwd = 3)
lines(size,gr2_low, col = 3,lty = 2, lwd = 3)
lines(size,gr2_mid, col = 3, lwd = 3)
lines(size,gr2_up, col = 3, lwd = 3,lty = 2)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")


pdf("..\\graphics\\Plot3.pdf", width = 7, height = 5)
plot(Grub$grubsize, Grub$value,  pch = 19,ylim = c(0,20), col = (Grub2$group + 2), lwd = 1.5,
      xlab = "Days", cex.lab = 1.4,
     ylab = "Overall survival probability")
lines(size,gr1_low, col = 2,lty = 2, lwd = 3)
lines(size,gr1_mid, col = 2, lwd = 3)
lines(size,gr1_up, col = 2,lty = 2, lwd = 3)
lines(size,gr2_low, col = 3,lty = 2, lwd = 3)
lines(size,gr2_mid, col = 3, lwd = 3)
lines(size,gr2_up, col = 3, lwd = 3,lty = 2)
legend("topright", legend = c("SS", "HB"),lwd = 3,
               lty = 1,col = c(2,3),
               title = "Groups")
dev.off()
```
##### Sensitivity
```{r}
source("Bayes1_lognormal_jags_sens.R")

```
The results are really simmular despite the second one has a really bad initilitation
```{r}
lognorm$summaries[,4]
lognorm_sens$summaries[,4]
lognorm_sens2$summaries[,4]
```